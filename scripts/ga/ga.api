api: google_analytics
url: |
  let propertyId = $QUERY_PARAMETERS.find(x => x['filter'] === 'ga_property_id')?.gaPropertyId?.value;
  return `https://analyticsdata.googleapis.com/v1beta/properties/${propertyId}:runReport`;
special:
  google_credentials: $ENV_GOOGLE_SERVICE_ACCOUNT_CREDENTIALS
method: POST
headers:
- key: Authorization
  value: Bearer $GOOGLE_ACCESS_TOKEN
- key: Content-Type
  value: application/json
body: |
  let orderByElements = [];

  $QUERY_ORDER_BY.forEach(x=> {
    let orderBy;

    if ($QUERY_SELECTED_DIMENSIONS.indexOf(x) > -1) {
      orderBy = {
        dimension: {
          dimensionName: x.name
        },
        desc: x.desc
      }
    } else if ($QUERY_SELECTED_MEASURES.indexOf(x) > -1) {
      orderBy = {
        metric: {
          metricName: x.name
        },
        desc: x.desc
      }
    }

    orderByElements.push(orderBy);
  });
  
  let dimensionFilterOrExpressions = [];
  let dimensionFilterAndNotExpressions = [];

  let metricFilterOrExpressions = [];
  let metricFilterAndNotExpressions = [];

  $QUERY_PARAMETERS.map(filter => {
    filter.fractions.forEach(fraction => {
      let apiFilter;
      let apiFilterType = fraction.option.meta.filter_type;

      if (apiFilterType === 'stringFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          stringFilter: {
            matchType: fraction.option.value,
            value: fraction.controls.find(x => x['input'] === 'valueInput').value,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'caseSensitiveSwitch')?.value
          }
        }
      }

      if (apiFilterType === 'inListFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          inListFilter: {
            values: fraction.controls.find(x => x['input'] === 'inListInput').values,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'caseSensitiveSwitch').value
          }
        }
      }

      if (apiFilterType === 'numericFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          numericFilter: {
            operation: fraction.option.value,
            value: fraction.controls.find(x => x['input'] === 'valueInput').value
          }
        }
      }

      if (apiFilterType === 'betweenFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          betweenFilter: {
            fromValue: fraction.controls.find(x => x['input'] === 'valueFromInput').value,
            toValue: fraction.controls.find(x => x['input'] === 'valueToInput').value,
          }
        }
      } 

      if (filter.field.fieldClass === 'dimension') {
        if (fraction.group === 'OR') {
          dimensionFilterOrExpressions.push({ filter: apiFilter })
        } else if (fraction.group === 'AND_NOT') {
          dimensionFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }

      if (filter.field.fieldClass === 'measure') {
        if (fraction.group === 'OR') {
          metricFilterOrExpressions.push({ filter: apiFilter })
        } else if (fraction.group === 'AND_NOT') {
          metricFilterAndNotExpressions.push({ filter: apiFilter })
        }
      }
    });
  });

  let body = {
    dimensions: $QUERY_SELECTED_DIMENSIONS,
    metrics: $QUERY_SELECTED_MEASURES,
    dimensionFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: dimensionFilterOrExpressions },
          ...dimensionFilterAndNotExpressions
        ]
      }
    },
    metricFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: metricFilterOrExpressions },
          ...metricFilterAndNotExpressions
        ]
      }
    },
    dateRanges: [{
      startDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range')?.startDate?.value,
      endDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range')?.endDate?.value
    }],
    orderBys: orderByElements,
    limit: $QUERY_LIMIT,
    currencyCode: USD,
    keepEmptyRows: true,
    returnPropertyQuota: false
  }

  return body;
response: |
  let data = $QUERY_RESPONSE;
  
  let dimensionHeaders = data.dimensionHeaders.map(header => header.name);
  let metricHeaders = data.metricHeaders.map(header => header.name);
  
  newData = data.rows.map(row => {
    let newRow = {};
    
    row.dimensionValues.forEach((dimension, index) => {
      let dimensionName = dimensionHeaders[index];
      newRow[dimensionName] = dimension.value;
    });
    
    row.metricValues.forEach((metric, index) => {
      let metricName = metricHeaders[index];
      newRow[metricName] = metric.value;
    });
    
    return newRow;
  });

  return newData;

initial_parameters:
- filter: ga_property_id
  required: true
  controls: 
  - selector: gaPropertyId
    value: $ENV_GA_PROPERTY_ID_1
    options: 
    - value: $ENV_GA_PROPERTY_ID_1
    - value: $ENV_GA_PROPERTY_ID_2

- filter: date_range
  required: true
  controls:
  - date_picker: startDate
    name: Start Date
    value: $QUERY_DATE_FROM
  - date_picker: endDate
    name: End Date
    value: $QUERY_DATE_TO

data_types:
- data_type: number
  options:
  - name: equal
    value: EQUAL
    meta: 
      filter_type: numericFilter
    controls: 
    - input: valueInput

  - name: less than
    value: LESS_THAN
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: valueInput

  - name: less than or equal
    value: LESS_THAN_OR_EQUAL
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: valueInput

  - name: greater than
    value: GREATER_THAN
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: valueInput

  - name: greater than or equal
    value: GREATER_THAN_OR_EQUAL
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: valueInput

  - name: between
    value: BETWEEN
    meta: 
      filter_type: betweenFilter
    controls:
    - input: valueFromInput
    - input: valueToInput

- data_type: string
  options:
  - name: exact
    value: EXACT
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: begins with
    value: BEGINS_WITH
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: ends with
    value: ENDS_WITH
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: contains
    value: CONTAINS
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: full regexp
    value: FULL_REGEXP
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: partial regexp
    value: PARTIAL_REGEXP
    meta: 
      filter_type: stringFilter
    controls:
    - input: valueInput
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: in list
    value: IN_LIST
    meta: 
      filter_type: inListFilter
    controls:
    - input: valueInput
      is_array: true
    - switch: caseSensitiveSwitch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

build_metrics:
- time_group: Event time
  units:
  - date: d1
  - month: d2
  - year: d3

fields:
- dimension: d1
  data_type: string
  group: g1

- dimension: d2
  data_type: string
  group: g1

- dimension: d3
  data_type: string

- measure: m1
  data_type: number

- measure: m2
  data_type: number

- measure: m3
  data_type: number