api: google_analytics
connection: google1
# connection_type: google
# connection_host: https://analyticsdata.googleapis.com
# connection_service_account_credentials: $ENV_GOOGLE_SERVICE_ACCOUNT_CREDENTIALS
# connection_headers:
# - key: Authorization
#   value: Bearer ...
# - key: Content-Type
#   value: application/json
method: POST
url_path: |
  let propertyId = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.ga_property.value;
  return `/v1beta/properties/${propertyId}:runReport`;
body: |
  let orderByElements = [];

  $QUERY_ORDER_BY.forEach(x=> {
    let orderBy;

    if ($QUERY_SELECTED_DIMENSIONS.indexOf(x) > -1) {
      orderBy = {
        dimension: { dimensionName: x.name },
        desc: x.desc
      }
    } else if ($QUERY_SELECTED_MEASURES.indexOf(x) > -1) {
      orderBy = {
        metric: { metricName: x.name },
        desc: x.desc
      }
    }

    orderByElements.push(orderBy);
  });
  
  let dimensionFilterOrExpressions = [];
  let dimensionFilterAndNotExpressions = [];

  let metricFilterOrExpressions = [];
  let metricFilterAndNotExpressions = [];

  $QUERY_PARAMETERS.map(filter => {
    filter.fractions.forEach(fraction => {
      let apiFilter;
      let apiFilterType = fraction.option?.meta?.filter_type;

      if (apiFilterType === 'stringFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          stringFilter: {
            matchType: fraction.option.value,
            value: fraction.controls.find(x => x['input'] === 'value_input').value,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'inListFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          inListFilter: {
            values: fraction.controls.find(x => x['input'] === 'inListInput').values,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'numericFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          numericFilter: {
            operation: fraction.option.value,
            value: fraction.controls.find(x => x['input'] === 'value_input').value
          }
        }
      }

      if (apiFilterType === 'betweenFilter') {
        apiFilter = {
          fieldName: x.fieldId,
          betweenFilter: {
            fromValue: fraction.controls.find(x => x['input'] === 'value_from_input').value,
            toValue: fraction.controls.find(x => x['input'] === 'value_to_input').value,
          }
        }
      } 

      if (filter.field?.fieldClass === 'dimension') {
        if (fraction.group === 'OR') {
          dimensionFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          dimensionFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }

      if (filter.field?.fieldClass === 'measure') {
        if (fraction.group === 'OR') {
          metricFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          metricFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }
    });
  });

  let isCohortsEnabled = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.cohorts_switch.value;

  let dateRanges;
  let cohortSpec;

  if (isCohortsEnabled === false) {
    dateRanges = [{
      startDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.start_date.value,
      endDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.end_date.value
    }],
  } else {
    let cohorts = [];

    $QUERY_PARAMETERS.find(x => x['filter'] === 'cohorts_config').fractions.forEach(fraction => {
      let cohort = {
        dimension: "firstSessionDate",
        dateRange: {
          startDate: fraction.controls.start_date.value,
          endDate: fraction.controls.end_date.value
        }
      }
      cohorts.push(cohort);
    });

    cohortSpec = {
      cohorts: cohorts,
      cohortsRange: {
        granularity: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.granularity.value,
        startOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.start_offset.value,
        endOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.end_offset.value,
      }
    };
  }

  let body = {
    dimensions: $QUERY_SELECTED_DIMENSIONS,
    metrics: $QUERY_SELECTED_MEASURES,
    dateRanges: dateRanges,
    dimensionFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: dimensionFilterOrExpressions },
          ...dimensionFilterAndNotExpressions
        ]
      }
    },
    metricFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: metricFilterOrExpressions },
          ...metricFilterAndNotExpressions
        ]
      }
    },
    offset: undefined, // not supported
    limit: $QUERY_LIMIT,
    metricAggregations: undefined, // not supported
    orderBys: orderByElements,
    currencyCode: USD,
    cohortSpec: cohortSpec,
    keepEmptyRows: true,
    returnPropertyQuota: false,
    comparisons: undefined // not supported
  }

  return body;
response: |
  let data = $QUERY_RESPONSE;
  
  let dimensionHeaders = data.dimensionHeaders.map(header => header.name);
  let metricHeaders = data.metricHeaders.map(header => header.name);
  
  newData = data.rows.map(row => {
    let newRow = {};
    
    row.dimensionValues.forEach((dimension, index) => {
      let dimensionName = dimensionHeaders[index];
      newRow[dimensionName] = dimension.value;
    });
    
    row.metricValues.forEach((metric, index) => {
      let metricName = metricHeaders[index];
      newRow[metricName] = metric.value;
    });
    
    return newRow;
  });

  return newData;

parameters:
- filter: top_config
  required: true
  min_fractions: 1
  max_fractions: 1
  controls: 
  - selector: ga_property
    required: true
    label: Property
    value: $ENV_GA_PROPERTY_ID_1
    options: 
    - value: $ENV_GA_PROPERTY_ID_1
    - value: $ENV_GA_PROPERTY_ID_2
  - switch: cohorts_switch
    required: true
    label: 'Cohorts Mode'
    value: false
  - selector: granularity
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: Granularity
    value: DAILY
    options: 
    - value: DAILY
    - value: WEEKLY
    - value: MONTHLY
  - input: start_offset
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: Start Offset # From
    value: 0
  - input: end_offset
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: End Offset # To
    value: 5

# - filter: cohorts_range
#   show_if: top_config.0.cohorts_switch.true
#   required: true
#   min_fractions: 1
#   max_fractions: 1
#   controls:
#   - selector: granularity ...

- filter: cohorts_config
  show_if: top_config.0.cohorts_switch.true
  required: true
  min_fractions: 1
  controls:
  - date_picker: start_date
    name: Start Date
    value: $DATE_TODAY
    required: true
  - date_picker: end_date
    name: End Date
    value: $DATE_TODAY
    required: true
  # - input: value_input
  #   label: name
  #   value: changedCohortFieldName
  # - input: value_input
  #   label: dimension
  #   value: firstSessionDate
  #   required: true
  #   lock: true

- filter: date_range
  show_if: top_config.0.cohorts_switch.false
  required: true
  min_fractions: 1
  max_fractions: 1
  controls:
  - date_picker: start_date
    name: Start Date
    value: $METRICS_DATE_FROM
  - date_picker: end_date
    name: End Date
    value: $METRICS_DATE_TO

data_types:
- data_type: number
  options:
  - name: equal
    value: EQUAL
    or: true
    and_not: true
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - name: less than
    value: LESS_THAN
    or: true
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - name: less than or equal
    value: LESS_THAN_OR_EQUAL
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - name: greater than
    value: GREATER_THAN
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - name: greater than or equal
    value: GREATER_THAN_OR_EQUAL
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - name: between
    value: BETWEEN
    meta: 
      filter_type: betweenFilter
    controls:
    - input: value_from_input
    - input: value_to_input

- data_type: string
  options:
  - name: exact
    value: EXACT
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: begins with
    value: BEGINS_WITH
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: ends with
    value: ENDS_WITH
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: contains
    value: CONTAINS
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: full regexp
    value: FULL_REGEXP
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: partial regexp
    value: PARTIAL_REGEXP
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - name: in list
    value: IN_LIST
    meta: 
      filter_type: inListFilter
    controls:
    - input: value_input
      is_array: true  # default false
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

build_metrics:
- time_group: 'Event Time'
  details:
  # - unit: quarters
  # - unit: timestamp
  - unit: years
    dimension: year # "2025"
    utc_ms: |
      let date = new Date(`${value}-01-01T00:00:00Z`);
      return date.getTime();
  - unit: months 
    dimension: yearMonth # "202501"
    utc_ms: |
      let date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-01T00:00:00Z`);
      return date.getTime();
  - unit: weeksMonday
    dimension: isoYearIsoWeek # "202504"
    utc_ms: |
      // Parse ISO year and week (e.g., "202504" → year=2025, week=4)
      const year = parseInt(value.slice(0, 4), 10);
      const week = parseInt(value.slice(4, 6), 10);
      
      // Create a date in week 1 of the ISO year (January 4th is always in week 1)
      const date = new Date(Date.UTC(year, 0, 4));
      
      // Get the Monday of week 1
      const day = date.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
      date.setUTCDate(date.getUTCDate() - (day === 0 ? 6 : day - 1));
      
      // Add weeks to reach the target week
      date.setUTCDate(date.getUTCDate() + (week - 1) * 7);
      
      return date.getTime();
  - unit: weeksSunday
    dimension: yearWeek # "202505"
    utc_ms: |
      // Parse year and week (e.g., "202505" → year=2025, week=5)
      const year = parseInt(value.slice(0, 4), 10);
      const week = parseInt(value.slice(4, 6), 10);
      
      // Find the first Sunday of the year
      const firstDay = new Date(Date.UTC(year, 0, 1));
      const day = firstDay.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
      const firstSunday = new Date(firstDay);
      firstSunday.setUTCDate(firstDay.getUTCDate() - day);
      
      // Add weeks to reach the target week
      const date = new Date(firstSunday);
      date.setUTCDate(firstSunday.getUTCDate() + (week - 1) * 7);
      
      return date.getTime();
  - unit: days
    dimension: date # "20250127"
    utc_ms: |
      let date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T00:00:00Z`);
      return date.getTime();
  - unit: hours
    dimension: dateHour # "2025012722"
    utc_ms: |
      let date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:00:00Z`);
      return date.getTime();
  - unit: minutes
    dimension: dateHourMinute # "202501272212"
    utc_ms: |
      let date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:${value.slice(10, 12)}:00Z`);
      return date.getTime();

field_groups:
- group: users
- group: sessions
- group: page_screens
  label: Page Screens
- group: geo
- group: cohorts
  show_if: top_config.0.cohorts_switch.true
- group: time

fields:

# Measures

- measure: activeUsers
  label: 'Active users'
  data_type: number
  description: 'The number of distinct users who visited your site or app',
  group: users
  meta:
    type: TYPE_INTEGER

- measure: sessions
  data_type: number
  description: 'The number of sessions that began on your site or app (event triggered: session_start)',
  group: sessions
  meta:
    type: TYPE_INTEGER

- measure: screenPageViews
  data_type: number
  description: 'The number of app screens or web pages your users viewed. Repeated views of a single page or screen are counted. (screen_view + page_view events)',
  group: page_screens
  meta:
    type: TYPE_INTEGER

## Cohort measures

- measure: cohortActiveUsers
  label: 'Cohort active users'
  data_type: number
  description: 'The number of users in the cohort who are active in the time window corresponding to the cohort nth day/week/month. For example in the row where cohortNthWeek = 0001, this metric is the number of users (in the cohort) who are active in week 1',
  group: cohorts
  meta:
    type: TYPE_INTEGER

- measure: cohortTotalUsers
  label: 'Cohort total users'
  data_type: number
  description: 'The total number of users in the cohort. This metric is the same value in every row of the report for each cohort. Because cohorts are defined by a shared acquisition date, cohortTotalUsers is the same as cohortActiveUsers for the cohort's selection date range. For report rows later than the cohort's selection range, it is typical for cohortActiveUsers to be smaller than cohortTotalUsers. This difference represents users from the cohort that were not active for the later date. cohortTotalUsers is commonly used in the metric expression cohortActiveUsers/cohortTotalUsers to compute a user retention fraction for the cohort. The relationship between activeUsers and totalUsers is not equivalent to the relationship between cohortActiveUsers and cohortTotalUsers',
  group: cohorts
  meta:
    type: TYPE_INTEGER    

# Dimensions

- dimension: country
  data_type: string
  description: 'The country from which the user activity originated',
  group: geo

- dimension: city
  data_type: string
  description: 'The city from which the user activity originated',
  group: geo

## Cohort dimensions

- dimension: cohort
  show_if: top_config.0.cohorts_switch.true
  required: true
  data_type: string
  description: 'The cohort's name in the request. A cohort is a set of users who started using your website or app in any consecutive group of days. If a cohort name is not specified in the request, cohorts are named by their zero based index such as cohort_0 and cohort_1',
  group: cohorts

- dimension: cohortNthDay
  label: Daily cohort
  data_type: string
  description: 'Day offset relative to the firstSessionDate for the users in the cohort. For example, if a cohort is selected with the start and end date of 2020-03-01, then for the date 2020-03-02, cohortNthDay will be 0001',
  group: cohorts

- dimension: cohortNthWeek
  label: Weekly cohort
  data_type: string
  description: 'Week offset relative to the firstSessionDate for the users in the cohort. Weeks start on Sunday and end on Saturday. For example, if a cohort is selected with the start and end date in the range 2020-11-08 to 2020-11-14, then for the dates in the range 2020-11-15 to 2020-11-21, cohortNthWeek will be 0001',
  group: cohorts

- dimension: cohortNthMonth
  label: Monthly cohort
  data_type: string
  description: 'Month offset relative to the firstSessionDate for the users in the cohort. Month boundaries align with calendar month boundaries. For example, if a cohort is selected with the start and end date in March 2020, then for any date in April 2020, cohortNthMonth will be 0001',
  group: cohorts

- dimension: cohortNthWeek
  label: 'Year'
  data_type: string
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  group: time

# Time dimensions

- dimension: year # "2025"
  label: 'Year'
  data_type: string
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  group: time

- dimension: yearMonth # "202501"
  label: 'Year month'
  data_type: string
  description: 'The combined values of year and month. Example values include 202212 or 202301',
  group: time

- dimension: isoYearIsoWeek # "202504"
  label: 'ISO week of ISO year'
  data_type: string
  description: 'The combined values of isoWeek and isoYear. Example values include 201652 & 201701',
  group: time

- dimension: yearWeek # "202505"
  label: 'Year week'
  data_type: string
  description: 'The combined values of year and week. Example values include 202253 or 202301',
  group: time

- dimension: date # "20250127"
  data_type: string
  description: 'The date of the event, formatted as YYYYMMDD',
  group: time

- dimension: dateHour # "2025012722"
  label: 'Date hour (YYYYMMDDHH)'
  data_type: string
  description: 'The combined values of date and hour formatted as YYYYMMDDHH',
  group: time

- dimension: dateHourMinute # "202501272212"
  label: 'Date hour and minute'
  data_type: string
  description: 'The combined values of date, hour, and minute formatted as YYYYMMDDHHMM',
  group: time

- dimension: hour # "4"
  data_type: string
  description: 'The two-digit hour of the day that the event was logged. This dimension ranges from 0-23 and is reported in your property's timezone',
  group: time

- dimension: minute # "40"
  data_type: string
  description: 'The two-digit minute of the hour that the event was logged. This dimension ranges from 0-59 and is reported in your property's timezone',
  group: time

- dimension: day # "26"
  data_type: string
  description: 'The day of the month, a two-digit number from 01 to 31',
  group: time

- dimension: dayOfWeek # "0"
  label: 'Day of week'
  data_type: string
  description: 'The integer day of the week. It returns values in the range 0 to 6 with Sunday as the first day of the week',
  group: time

- dimension: dayOfWeekName # "Sunday"
  label: 'Day of week name'
  data_type: string
  description: 'The day of the week in English. This dimension has values such as Sunday or Monday',
  group: time

- dimension: week # "05"
  label: 'Week'
  data_type: string
  description: 'The week of the event, a two-digit number from 01 to 53. Each week starts on Sunday. January 1st is always in week 01. The first and last week of the year have fewer than 7 days in most years. Weeks other than the first and the last week of the year always have 7 days. For years where January 1st is a Sunday, the first week of that year and the last week of the prior year have 7 days',
  group: time

- dimension: month # "01"
  data_type: string
  description: 'The month of the event, a two digit integer from 01 to 12',
  group: time

- dimension: isoYear # "2025"
  label: 'ISO year'
  data_type: string
  description: 'The ISO year of the event. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 2022 & 2023',
  group: time

- dimension: isoWeek # "04"
  label: 'ISO week of the year'
  data_type: string
  description: 'ISO week number, where each week starts on Monday. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 01, 02, & 53',
  group: time

- dimension: nthYear # "0000"
  label: 'Nth year'
  data_type: string
  description: 'The number of years since the start of the date range. The starting year is 0000',
  group: time

- dimension: nthMonth # "0000"
  label: 'Nth month'
  data_type: string
  description: 'The number of months since the start of a date range. The starting month is 0000',
  group: time

- dimension: nthWeek # "0001"
  label: 'Nth week'
  data_type: string
  description: 'A number representing the number of weeks since the start of a date range',
  group: time

- dimension: nthDay # "0004"
  label: 'Nth day'
  data_type: string
  description: 'The number of days since the start of the date range',
  group: time

- dimension: nthHour # "0142"
  label: 'Nth hour'
  data_type: string
  description: 'The number of hours since the start of the date range. The starting hour is 0000',
  group: time

- dimension: nthMinute # "8532"
  label: 'Nth minute'
  data_type: string
  description: 'The number of minutes since the start of the date range. The starting minute is 0000',
  group: time
