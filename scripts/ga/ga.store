store: google_analytics
connection: google1
label: Google Analytics
description: '...'
access_users: []
access_roles: []
# connection_type: google
# connection_host: https://analyticsdata.googleapis.com
# connection_service_account_credentials: $ENV_GOOGLE_SERVICE_ACCOUNT_CREDENTIALS
# connection_headers:
# - key: Authorization
#   value: Bearer ...
# - key: Content-Type
#   value: application/json
method: POST
url_path: |
  let propertyId = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.ga_property.value;
  return `/v1beta/properties/${propertyId}:runReport`;
body: |
  let orderByElements = [];

  $QUERY_ORDER_BY.forEach(x=> {
    let orderBy;

    if ($QUERY_SELECTED_DIMENSIONS.indexOf(x) > -1) {
      orderBy = {
        dimension: { dimensionName: x.meta.name },
        desc: x.desc
      }
    } else if ($QUERY_SELECTED_MEASURES.indexOf(x) > -1) {
      orderBy = {
        metric: { metricName: x.meta.name },
        desc: x.desc
      }
    }

    orderByElements.push(orderBy);
  });
  
  let dimensionFilterOrExpressions = [];
  let dimensionFilterAndNotExpressions = [];

  let metricFilterOrExpressions = [];
  let metricFilterAndNotExpressions = [];

  $QUERY_PARAMETERS.map(filter => {
    filter.fractions.forEach(fraction => {
      let apiFilter;
      let apiFilterType = fraction.meta?.filter_type;

      if (apiFilterType === 'stringFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          stringFilter: {
            matchType: fraction.meta.match_type,
            value: fraction.controls.find(x => x['input'] === 'value_input').value,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'inListFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          inListFilter: {
            values: fraction.controls.find(x => x['input'] === 'inListInput').values,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'numericFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          numericFilter: {
            operation: fraction.meta.operation,
            value: fraction.controls.find(x => x['input'] === 'value_input').value
          }
        }
      }

      if (apiFilterType === 'betweenFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          betweenFilter: {
            fromValue: fraction.controls.find(x => x['input'] === 'value_from_input').value,
            toValue: fraction.controls.find(x => x['input'] === 'value_to_input').value,
          }
        }
      } 

      if (filter.field?.fieldClass === 'dimension') {
        if (fraction.group === 'OR') {
          dimensionFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          dimensionFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }

      if (filter.field?.fieldClass === 'measure') {
        if (fraction.group === 'OR') {
          metricFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          metricFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }
    });
  });

  let isCohortsEnabled = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.cohorts_switch.value;

  let dateRanges;
  let cohortSpec;

  if (isCohortsEnabled === false) {
    dateRanges = [{
      startDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.start_date.value,
      endDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.end_date.value
    }],
  } else {
    let cohorts = [];

    $QUERY_PARAMETERS.find(x => x['filter'] === 'cohorts_config').fractions.forEach(fraction => {
      let cohort = {
        dimension: "firstSessionDate",
        dateRange: {
          startDate: fraction.controls.start_date.value,
          endDate: fraction.controls.end_date.value
        }
      }
      cohorts.push(cohort);
    });

    cohortSpec = {
      cohorts: cohorts,
      cohortsRange: {
        granularity: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.granularity.value,
        startOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.start_offset.value,
        endOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.end_offset.value,
      }
    };
  }

  let body = {
    dimensions: $QUERY_SELECTED_DIMENSIONS,
    metrics: $QUERY_SELECTED_MEASURES,
    dateRanges: dateRanges,
    dimensionFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: dimensionFilterOrExpressions },
          ...dimensionFilterAndNotExpressions
        ]
      }
    },
    metricFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: metricFilterOrExpressions },
          ...metricFilterAndNotExpressions
        ]
      }
    },
    offset: undefined, // not supported
    limit: $QUERY_LIMIT,
    metricAggregations: undefined, // not supported
    orderBys: orderByElements,
    currencyCode: USD,
    cohortSpec: cohortSpec,
    keepEmptyRows: true,
    returnPropertyQuota: false,
    comparisons: undefined // not supported
  }

  return body;
response: |
  let data = $QUERY_RESPONSE;
  
  let dimensionHeaders = data.dimensionHeaders.map(header => header.name);
  let metricHeaders = data.metricHeaders.map(header => header.name);
  
  newData = data.rows.map(row => {
    let newRow = {};
    
    row.dimensionValues.forEach((dimension, index) => {
      let dimensionName = dimensionHeaders[index];
      let date;

      if (dimensionName === 'year') {
        date = new Date(`${value}-01-01T00:00:00Z`);
        //
      } else if (dimensionName === 'yearMonth') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-01T00:00:00Z`);
        //
      } else if (dimensionName === 'isoYearIsoWeek') {
        // Parse ISO year and week (e.g., "202504" → year=2025, week=4)
        // Create a date in week 1 of the ISO year (January 4th is always in week 1)
        // Get the Monday of week 1
        // Add weeks to reach the target week

        let year = parseInt(value.slice(0, 4), 10);
        let week = parseInt(value.slice(4, 6), 10);
        
        date = new Date(Date.UTC(year, 0, 4));
        
        let day = date.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
        date.setUTCDate(date.getUTCDate() - (day === 0 ? 6 : day - 1));
        
        date.setUTCDate(date.getUTCDate() + (week - 1) * 7);
        //
      } else if (dimensionName === 'yearWeek') {
        // Parse year and week (e.g., "202505" → year=2025, week=5)
        // Find the first Sunday of the year
        // Add weeks to reach the target week

        let year = parseInt(value.slice(0, 4), 10);
        let week = parseInt(value.slice(4, 6), 10);
        
        let firstDay = new Date(Date.UTC(year, 0, 1));
        let day = firstDay.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
        let firstSunday = new Date(firstDay);
        firstSunday.setUTCDate(firstDay.getUTCDate() - day);
        
        date = new Date(firstSunday);
        date.setUTCDate(firstSunday.getUTCDate() + (week - 1) * 7);
        //
      } else if (dimensionName === 'date') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T00:00:00Z`);
        //
      } else if (dimensionName === 'dateHour') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:00:00Z`);
        //
      } else if (dimensionName === 'dateHourMinute') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:${value.slice(10, 12)}:00Z`);
      } 

      let fieldId = $QUERY_FIELDS.find(x => x.meta['name'] === dimensionName).id;

      if (!!fieldId) {
        if (!!date) {
          let fieldIdUTC = fieldId + $UTC_MS_SUFFIX;
          newRow[fieldIdUTC] = date.getTime();
        }
        newRow[fieldId] = dimension.value;
      }
    });
    
    row.metricValues.forEach((metric, index) => {
      let metricName = metricHeaders[index];
      let fieldId = $QUERY_FIELDS.find(x => x.meta['name'] === metricName).id;
      if (!!fieldId) {
        newRow[fieldId] = metric.value;
      }
    });
    
    return newRow;
  });

  return newData;

parameters:
- filter: top_config
  required: true
  max_fractions: 1
  fraction_controls:
  - selector: ga_property
    required: true
    label: Property
    value: $ENV_GA_PROPERTY_ID_1
    options:
    - value: $ENV_GA_PROPERTY_ID_1
    - value: $ENV_GA_PROPERTY_ID_2
  - switch: cohorts_switch
    required: true
    label: 'Cohorts Mode'
    value: false
  - selector: granularity
    show_if: top_config.cohorts_switch.true
    required: true
    label: Granularity
    value: DAILY
    options: 
    - value: DAILY
    - value: WEEKLY
    - value: MONTHLY
  - input: start_offset
    show_if: top_config.cohorts_switch.true
    required: true
    label: Start Offset # From
    value: 0
  - input: end_offset
    show_if: top_config.cohorts_switch.true
    required: true
    label: End Offset # To
    value: 5

# - filter: cohorts_range
#   show_if: top_config.cohorts_switch.true
#   required: true
#   max_fractions: 1
#   controls:
#   - selector: granularity ...

- filter: cohorts_config
  show_if: top_config.cohorts_switch.true
  required: true
  fraction_controls:
  - date_picker: start_date
    label: Start Date
    value: $DATE_TODAY
    required: true
  - date_picker: end_date
    label: End Date
    value: $DATE_TODAY
    required: true
  # - input: value_input
  #   label: name
  #   value: 'changed cohort field name'
  # - input: value_input
  #   label: dimension
  #   value: firstSessionDate
  #   required: true
  #   lock: true

- filter: date_range
  show_if: top_config.cohorts_switch.false
  required: true
  max_fractions: 1
  fraction_controls: 
  - date_picker: start_date
    label: Start Date
    value: $METRICS_DATE_FROM
  - date_picker: end_date
    label: End Date
    value: $METRICS_DATE_TO

results:
- result: number
  fraction_types:
  - type: equal
    label: Equal
    or: true
    and_not: true
    meta: 
      operation: EQUAL
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: less_than
    or: true
    and_not: false
    meta: 
      operation: LESS_THAN
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: less_than_or_equal
    and_not: false
    meta: 
      operation: LESS_THAN_OR_EQUAL
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: greater_than
    and_not: false
    meta: 
      operation: GREATER_THAN
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: greater_than_or_equal
    and_not: false
    meta: 
      operation: GREATER_THAN_OR_EQUAL
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: between
    meta: 
      operation: BETWEEN
      filter_type: betweenFilter
    controls:
    - input: value_from_input
    - input: value_to_input

- result: string
  fraction_types:
  - type: exact
    meta: 
      match_type: EXACT
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: begins_with
    meta: 
      match_type: BEGINS_WITH
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: ends_with
    meta: 
      match_type: ENDS_WITH
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: contains
    meta: 
      match_type: CONTAINS
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: full_regexp
    meta: 
      match_type: FULL_REGEXP
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: partial_regexp
    meta: 
      match_type: PARTIAL_REGEXP
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: in_list
    meta: 
      match_type: IN_LIST
      filter_type: inListFilter
    controls:
    - input: value_input
      is_array: true  # default false
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

build_metrics:
- time_name: event_time
  time_label: 'Event Time'
  details:
  - unit: years
    dimension: year
  - unit: months 
    dimension: year_month
  - unit: weeksMonday
    dimension: iso_year_iso_week
  - unit: weeksSunday
    dimension: year_week
  - unit: days
    dimension: date
  - unit: hours
    dimension: date_hour
  - unit: minutes
    dimension: date_hour_minute
  # - unit: quarters
  # - unit: timestamp

field_groups:
- group: geo
- group: time
- group: cohorts
  label: Cohorts
  show_if: top_config.cohorts_switch.true # TODO: check
- group: users
- group: sessions
- group: page_screens

fields:
# Measures
- measure: active_users
  result: number
  group: users
  description: 'The number of distinct users who visited your site or app',
  meta:
    name: activeUsers
    type: TYPE_INTEGER

- measure: sessions
  result: number
  group: sessions
  description: 'The number of sessions that began on your site or app (event triggered: session_start)',
  meta:
    name: sessions
    type: TYPE_INTEGER

- measure: screen_page_views
  result: number
  group: page_screens
  description: 'The number of app screens or web pages your users viewed. Repeated views of a single page or screen are counted. (screen_view + page_view events)',
  meta:
    name: screenPageViews
    type: TYPE_INTEGER
## Cohort measures
- measure: cohort_active_users
  label: 'Cohort active users'
  result: number
  group: cohorts
  description: 'The number of users in the cohort who are active in the time window corresponding to the cohort nth day/week/month. For example in the row where cohortNthWeek = 0001, this metric is the number of users (in the cohort) who are active in week 1',
  meta:
    name: cohortActiveUsers
    type: TYPE_INTEGER

- measure: cohort_total_users
  label: 'Cohort total users'
  result: number
  group: cohorts
  description: "The total number of users in the cohort. This metric is the same value in every row of the report for each cohort. Because cohorts are defined by a shared acquisition date, cohortTotalUsers is the same as cohortActiveUsers for the cohort's selection date range. For report rows later than the cohort's selection range, it is typical for cohortActiveUsers to be smaller than cohortTotalUsers. This difference represents users from the cohort that were not active for the later date. cohortTotalUsers is commonly used in the metric expression cohortActiveUsers/cohortTotalUsers to compute a user retention fraction for the cohort. The relationship between activeUsers and totalUsers is not equivalent to the relationship between cohortActiveUsers and cohortTotalUsers",
  meta:
    name: cohortTotalUsers
    type: TYPE_INTEGER    
# Dimensions
- dimension: country
  result: string
  group: geo
  description: 'The country from which the user activity originated',
  meta:
    name: country

- dimension: city
  result: string
  group: geo
  description: 'The city from which the user activity originated',
  meta:
    name: city
## Cohort dimensions
- dimension: cohort
  result: string
  group: cohorts
  show_if: top_config.cohorts_switch.true
  required: true
  description: "The cohort's name in the request. A cohort is a set of users who started using your website or app in any consecutive group of days. If a cohort name is not specified in the request, cohorts are named by their zero based index such as cohort_0 and cohort_1",
  meta:
    name: cohort

- dimension: cohort_nth_day
  label: Daily cohort
  result: string
  group: cohorts
  description: 'Day offset relative to the firstSessionDate for the users in the cohort. For example, if a cohort is selected with the start and end date of 2020-03-01, then for the date 2020-03-02, cohortNthDay will be 0001',
  meta:
    name: cohortNthDay

- dimension: cohort_nth_week
  label: Weekly cohort
  result: string
  group: cohorts
  description: 'Week offset relative to the firstSessionDate for the users in the cohort. Weeks start on Sunday and end on Saturday. For example, if a cohort is selected with the start and end date in the range 2020-11-08 to 2020-11-14, then for the dates in the range 2020-11-15 to 2020-11-21, cohortNthWeek will be 0001',
  meta:
    name: cohortNthWeek

- dimension: cohort_nth_month
  label: Monthly cohort
  result: string
  group: cohorts
  description: 'Month offset relative to the firstSessionDate for the users in the cohort. Month boundaries align with calendar month boundaries. For example, if a cohort is selected with the start and end date in March 2020, then for any date in April 2020, cohortNthMonth will be 0001',
  meta:
    name: cohortNthMonth

- dimension: cohort_nth_week
  label: 'Year'
  result: string
  group: cohorts
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  meta:
    name: cohortNthWeek
# Time dimensions
- dimension: year # "2025"
  label: 'Year'
  result: string
  group: time
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  meta:
    name: year

- dimension: year_month # "202501"
  label: 'Year month'
  result: string
  group: time
  description: 'The combined values of year and month. Example values include 202212 or 202301',
  meta:
    name: yearMonth

- dimension: iso_year_iso_week # "202504"
  label: 'ISO week of ISO year'
  result: string
  group: time
  description: 'The combined values of isoWeek and isoYear. Example values include 201652 & 201701',
  meta:
    name: isoYearIsoWeek

- dimension: year_week # "202505"
  label: 'Year week'
  result: string
  group: time
  description: 'The combined values of year and week. Example values include 202253 or 202301',
  meta:
    name: yearWeek

- dimension: date # "20250127"
  result: string
  group: time
  description: 'The date of the event, formatted as YYYYMMDD',
  meta:
    name: date

- dimension: date_hour # "2025012722"
  label: 'Date hour (YYYYMMDDHH)'
  result: string
  group: time
  description: 'The combined values of date and hour formatted as YYYYMMDDHH',
  meta:
    name: dateHour

- dimension: date_hour_minute # "202501272212"
  label: 'Date hour and minute'
  result: string
  group: time
  description: 'The combined values of date, hour, and minute formatted as YYYYMMDDHHMM',
  meta:
    name: dateHourMinute

- dimension: hour # "4"
  result: string
  group: time
  description: "The two-digit hour of the day that the event was logged. This dimension ranges from 0-23 and is reported in your property's timezone",
  meta:
    name: hour

- dimension: minute # "40"
  result: string
  group: time
  description: "The two-digit minute of the hour that the event was logged. This dimension ranges from 0-59 and is reported in your property's timezone",
  meta:
    name: minute

- dimension: day # "26"
  result: string
  group: time
  description: 'The day of the month, a two-digit number from 01 to 31',
  meta:
    name: day

- dimension: day_of_week # "0"
  label: 'Day of week'
  result: string
  group: time
  description: 'The integer day of the week. It returns values in the range 0 to 6 with Sunday as the first day of the week',
  meta:
    name: dayOfWeek

- dimension: day_of_week_name # "Sunday"
  label: 'Day of week name'
  result: string
  group: time
  description: 'The day of the week in English. This dimension has values such as Sunday or Monday',
  meta:
    name: dayOfWeekName

- dimension: week # "05"
  label: 'Week'
  result: string
  group: time
  description: 'The week of the event, a two-digit number from 01 to 53. Each week starts on Sunday. January 1st is always in week 01. The first and last week of the year have fewer than 7 days in most years. Weeks other than the first and the last week of the year always have 7 days. For years where January 1st is a Sunday, the first week of that year and the last week of the prior year have 7 days',
  meta:
    name: week

- dimension: month # "01"
  result: string
  group: time
  description: 'The month of the event, a two digit integer from 01 to 12',
  meta:
    name: month

- dimension: iso_year # "2025"
  label: 'ISO year'
  result: string
  group: time
  description: 'The ISO year of the event. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 2022 & 2023',
  meta:
    name: isoYear

- dimension: iso_week # "04"
  label: 'ISO week of the year'
  result: string
  group: time
  description: 'ISO week number, where each week starts on Monday. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 01, 02, & 53',
  meta:
    name: isoWeek

- dimension: nth_year # "0000"
  label: 'Nth year'
  result: string
  description: 'The number of years since the start of the date range. The starting year is 0000',
  group: time
  meta:
    name: nthYear

- dimension: nth_month # "0000"
  label: 'Nth month'
  result: string
  group: time
  description: 'The number of months since the start of a date range. The starting month is 0000',
  meta:
    name: nthMonth

- dimension: nth_week # "0001"
  label: 'Nth week'
  result: string
  group: time
  description: 'A number representing the number of weeks since the start of a date range',
  meta:
    name: nthWeek

- dimension: nth_day # "0004"
  label: 'Nth day'
  result: string
  group: time
  description: 'The number of days since the start of the date range',
  meta:
    name: nthDay

- dimension: nth_hour # "0142"
  label: 'Nth hour'
  result: string
  group: time
  description: 'The number of hours since the start of the date range. The starting hour is 0000',
  meta:
    name: nthHour

- dimension: nth_minute # "8532"
  label: 'Nth minute'
  result: string
  group: time
  description: 'The number of minutes since the start of the date range. The starting minute is 0000',
  meta:
    name: nthMinute
