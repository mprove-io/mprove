store: google_analytics
connection: google1
label: Google Analytics
description: '...'
access_users: []
access_roles: []
# connection_type: google
# connection_host: https://analyticsdata.googleapis.com
# connection_service_account_credentials: $ENV_GOOGLE_SERVICE_ACCOUNT_CREDENTIALS
# connection_headers:
# - key: Authorization
#   value: Bearer ...
# - key: Content-Type
#   value: application/json
method: POST
url_path: |
  let propertyId = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.ga_property.value;
  return `/v1beta/properties/${propertyId}:runReport`;
body: |
  let orderByElements = [];

  $QUERY_ORDER_BY.forEach(x=> {
    let orderBy;

    if ($QUERY_SELECTED_DIMENSIONS.indexOf(x) > -1) {
      orderBy = {
        dimension: { dimensionName: x.meta.name },
        desc: x.desc
      }
    } else if ($QUERY_SELECTED_MEASURES.indexOf(x) > -1) {
      orderBy = {
        metric: { metricName: x.meta.name },
        desc: x.desc
      }
    }

    orderByElements.push(orderBy);
  });
  
  let dimensionFilterOrExpressions = [];
  let dimensionFilterAndNotExpressions = [];

  let metricFilterOrExpressions = [];
  let metricFilterAndNotExpressions = [];

  $QUERY_PARAMETERS.map(filter => {
    filter.fractions.forEach(fraction => {
      let apiFilter;
      let apiFilterType = fraction.meta?.filter_type;

      if (apiFilterType === 'stringFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          stringFilter: {
            matchType: fraction.type,
            value: fraction.controls.find(x => x['input'] === 'value_input').value,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'inListFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          inListFilter: {
            values: fraction.controls.find(x => x['input'] === 'inListInput').values,
            caseSensitive: fraction.controls.find(x => x['switch'] === 'case_sensitive_switch').value
          }
        }
      }

      if (apiFilterType === 'numericFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          numericFilter: {
            operation: fraction.type,
            value: fraction.controls.find(x => x['input'] === 'value_input').value
          }
        }
      }

      if (apiFilterType === 'betweenFilter') {
        apiFilter = {
          fieldName: x.field.meta.name,
          betweenFilter: {
            fromValue: fraction.controls.find(x => x['input'] === 'value_from_input').value,
            toValue: fraction.controls.find(x => x['input'] === 'value_to_input').value,
          }
        }
      } 

      if (filter.field?.fieldClass === 'dimension') {
        if (fraction.group === 'OR') {
          dimensionFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          dimensionFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }

      if (filter.field?.fieldClass === 'measure') {
        if (fraction.group === 'OR') {
          metricFilterOrExpressions.push({ filter: apiFilter })
        } 
        if (fraction.group === 'AND_NOT') {
          metricFilterAndNotExpressions.push({
            notExpression: {
              filter: apiFilter
            }
          })
        }
      }
    });
  });

  let isCohortsEnabled = $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.cohorts_switch.value;

  let dateRanges;
  let cohortSpec;

  if (isCohortsEnabled === false) {
    dateRanges = [{
      startDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.start_date.value,
      endDate: $QUERY_PARAMETERS.find(x => x['filter'] === 'date_range').fractions[0].controls.end_date.value
    }],
  } else {
    let cohorts = [];

    $QUERY_PARAMETERS.find(x => x['filter'] === 'cohorts_config').fractions.forEach(fraction => {
      let cohort = {
        dimension: "firstSessionDate",
        dateRange: {
          startDate: fraction.controls.start_date.value,
          endDate: fraction.controls.end_date.value
        }
      }
      cohorts.push(cohort);
    });

    cohortSpec = {
      cohorts: cohorts,
      cohortsRange: {
        granularity: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.granularity.value,
        startOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.start_offset.value,
        endOffset: $QUERY_PARAMETERS.find(x => x['filter'] === 'top_config').fractions[0].controls.end_offset.value,
      }
    };
  }

  let body = {
    dimensions: $QUERY_SELECTED_DIMENSIONS,
    metrics: $QUERY_SELECTED_MEASURES,
    dateRanges: dateRanges,
    dimensionFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: dimensionFilterOrExpressions },
          ...dimensionFilterAndNotExpressions
        ]
      }
    },
    metricFilter: {
      andGroup: {
        expressions: [
          orGroup: { expressions: metricFilterOrExpressions },
          ...metricFilterAndNotExpressions
        ]
      }
    },
    offset: undefined, // not supported
    limit: $QUERY_LIMIT,
    metricAggregations: undefined, // not supported
    orderBys: orderByElements,
    currencyCode: USD,
    cohortSpec: cohortSpec,
    keepEmptyRows: true,
    returnPropertyQuota: false,
    comparisons: undefined // not supported
  }

  return body;
response: |
  let data = $QUERY_RESPONSE;
  
  let dimensionHeaders = data.dimensionHeaders.map(header => header.name);
  let metricHeaders = data.metricHeaders.map(header => header.name);
  
  newData = data.rows.map(row => {
    let newRow = {};
    
    row.dimensionValues.forEach((dimension, index) => {
      let dimensionName = dimensionHeaders[index];
      let date;

      if (dimensionName === 'year') {
        date = new Date(`${value}-01-01T00:00:00Z`);
        //
      } else if (dimensionName === 'yearMonth') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-01T00:00:00Z`);
        //
      } else if (dimensionName === 'isoYearIsoWeek') {
        // Parse ISO year and week (e.g., "202504" → year=2025, week=4)
        // Create a date in week 1 of the ISO year (January 4th is always in week 1)
        // Get the Monday of week 1
        // Add weeks to reach the target week

        let year = parseInt(value.slice(0, 4), 10);
        let week = parseInt(value.slice(4, 6), 10);
        
        date = new Date(Date.UTC(year, 0, 4));
        
        let day = date.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
        date.setUTCDate(date.getUTCDate() - (day === 0 ? 6 : day - 1));
        
        date.setUTCDate(date.getUTCDate() + (week - 1) * 7);
        //
      } else if (dimensionName === 'yearWeek') {
        // Parse year and week (e.g., "202505" → year=2025, week=5)
        // Find the first Sunday of the year
        // Add weeks to reach the target week

        let year = parseInt(value.slice(0, 4), 10);
        let week = parseInt(value.slice(4, 6), 10);
        
        let firstDay = new Date(Date.UTC(year, 0, 1));
        let day = firstDay.getUTCDay(); // 0 (Sunday) to 6 (Saturday)
        let firstSunday = new Date(firstDay);
        firstSunday.setUTCDate(firstDay.getUTCDate() - day);
        
        date = new Date(firstSunday);
        date.setUTCDate(firstSunday.getUTCDate() + (week - 1) * 7);
        //
      } else if (dimensionName === 'date') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T00:00:00Z`);
        //
      } else if (dimensionName === 'dateHour') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:00:00Z`);
        //
      } else if (dimensionName === 'dateHourMinute') {
        date = new Date(`${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}T${value.slice(8, 10)}:${value.slice(10, 12)}:00Z`);
      } 

      let fieldId = $QUERY_FIELDS.find(x => x.meta['name'] === dimensionName).id;

      if (!!fieldId) {
        if (!!date) {
          let fieldIdUTC = fieldId + $UTC_MS_SUFFIX;
          newRow[fieldIdUTC] = date.getTime();
        }
        newRow[fieldId] = dimension.value;
      }
    });
    
    row.metricValues.forEach((metric, index) => {
      let metricName = metricHeaders[index];
      let fieldId = $QUERY_FIELDS.find(x => x.meta['name'] === metricName).id;
      if (!!fieldId) {
        newRow[fieldId] = metric.value;
      }
    });
    
    return newRow;
  });

  return newData;

parameters:
- filter: top_config
  required: true
  max_fractions: 1
  fraction_controls: 
  - selector: ga_property
    required: true
    label: Property
    value: $ENV_GA_PROPERTY_ID_1
    options: 
    - value: $ENV_GA_PROPERTY_ID_1
    - value: $ENV_GA_PROPERTY_ID_2
  - switch: cohorts_switch
    required: true
    label: 'Cohorts Mode'
    value: false
  - selector: granularity
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: Granularity
    value: DAILY
    options: 
    - value: DAILY
    - value: WEEKLY
    - value: MONTHLY
  - input: start_offset
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: Start Offset # From
    value: 0
  - input: end_offset
    show_if: top_config.0.cohorts_switch.true
    required: true
    label: End Offset # To
    value: 5

# - filter: cohorts_range
#   show_if: top_config.0.cohorts_switch.true
#   required: true
#   max_fractions: 1
#   controls:
#   - selector: granularity ...

- filter: cohorts_config
  show_if: top_config.0.cohorts_switch.true
  required: true
  fraction_controls:
  - date_picker: start_date
    name: Start Date
    value: $DATE_TODAY
    required: true
  - date_picker: end_date
    name: End Date
    value: $DATE_TODAY
    required: true
  # - input: value_input
  #   label: name
  #   value: 'changed cohort field name'
  # - input: value_input
  #   label: dimension
  #   value: firstSessionDate
  #   required: true
  #   lock: true

- filter: date_range
  show_if: top_config.0.cohorts_switch.false
  required: true
  max_fractions: 1
  fraction_controls:
  - date_picker: start_date
    name: Start Date
    value: $METRICS_DATE_FROM
  - date_picker: end_date
    name: End Date
    value: $METRICS_DATE_TO

results:
- result: number
  fraction_types:
  - type: EQUAL
    name: equal
    or: true
    and_not: true
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: LESS_THAN
    name: less than
    or: true
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: LESS_THAN_OR_EQUAL
    name: less than or equal
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: GREATER_THAN
    name: greater than
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: GREATER_THAN_OR_EQUAL
    name: greater than or equal
    and_not: false
    meta: 
      filter_type: numericFilter
    controls: 
    - input: value_input

  - type: BETWEEN
    name: between
    meta: 
      filter_type: betweenFilter
    controls:
    - input: value_from_input
    - input: value_to_input

- result: string
  fraction_types:
  - type: EXACT
    name: exact
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: BEGINS_WITH
    name: begins with
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: ENDS_WITH
    name: ends with
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: CONTAINS
    name: contains
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: FULL_REGEXP
    name: full regexp
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: PARTIAL_REGEXP
    name: partial regexp
    meta: 
      filter_type: stringFilter
    controls:
    - input: value_input
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

  - type: IN_LIST
    name: in list
    meta: 
      filter_type: inListFilter
    controls:
    - input: value_input
      is_array: true  # default false
    - switch: case_sensitive_switch
      label: Case Sensitive
      value: $PROJECT_CONFIG_CASE_SENSITIVE

build_metrics:
- time_label: 'Event Time'
  details:
  - unit: years
    dimension: year
  - unit: months 
    dimension: year_month
  - unit: weeksMonday
    dimension: iso_year_iso_week
  - unit: weeksSunday
    dimension: year_week
  - unit: days
    dimension: date
  - unit: hours
    dimension: date_hour
  - unit: minutes
    dimension: date_hour_minute
  # - unit: quarters
  # - unit: timestamp

field_groups:
- group: geo
- group: time
- group: cohorts
  label: Cohorts
  show_if: top_config.0.cohorts_switch.true
- group: users
- group: sessions
- group: page_screens

fields:
# Measures
- measure: active_users
  result: number
  description: 'The number of distinct users who visited your site or app',
  group: users
  meta:
    name: activeUsers
    type: TYPE_INTEGER

- measure: sessions
  result: number
  description: 'The number of sessions that began on your site or app (event triggered: session_start)',
  group: sessions
  meta:
    name: sessions
    type: TYPE_INTEGER

- measure: screen_page_views
  result: number
  description: 'The number of app screens or web pages your users viewed. Repeated views of a single page or screen are counted. (screen_view + page_view events)',
  group: page_screens
  meta:
    name: screenPageViews
    type: TYPE_INTEGER
## Cohort measures
- measure: cohort_active_users
  label: 'Cohort active users'
  result: number
  description: 'The number of users in the cohort who are active in the time window corresponding to the cohort nth day/week/month. For example in the row where cohortNthWeek = 0001, this metric is the number of users (in the cohort) who are active in week 1',
  group: cohorts
  meta:
    name: cohortActiveUsers
    type: TYPE_INTEGER

- measure: cohort_total_users
  label: 'Cohort total users'
  result: number
  description: 'The total number of users in the cohort. This metric is the same value in every row of the report for each cohort. Because cohorts are defined by a shared acquisition date, cohortTotalUsers is the same as cohortActiveUsers for the cohort's selection date range. For report rows later than the cohort's selection range, it is typical for cohortActiveUsers to be smaller than cohortTotalUsers. This difference represents users from the cohort that were not active for the later date. cohortTotalUsers is commonly used in the metric expression cohortActiveUsers/cohortTotalUsers to compute a user retention fraction for the cohort. The relationship between activeUsers and totalUsers is not equivalent to the relationship between cohortActiveUsers and cohortTotalUsers',
  group: cohorts
  meta:
    name: cohortTotalUsers
    type: TYPE_INTEGER    
# Dimensions
- dimension: country
  result: string
  description: 'The country from which the user activity originated',
  group: geo
  meta:
    name: country

- dimension: city
  result: string
  description: 'The city from which the user activity originated',
  group: geo
  meta:
    name: city
## Cohort dimensions
- dimension: cohort
  show_if: top_config.0.cohorts_switch.true
  required: true
  result: string
  description: 'The cohort's name in the request. A cohort is a set of users who started using your website or app in any consecutive group of days. If a cohort name is not specified in the request, cohorts are named by their zero based index such as cohort_0 and cohort_1',
  group: cohorts
  meta:
    name: cohort

- dimension: cohort_nth_day
  label: Daily cohort
  result: string
  description: 'Day offset relative to the firstSessionDate for the users in the cohort. For example, if a cohort is selected with the start and end date of 2020-03-01, then for the date 2020-03-02, cohortNthDay will be 0001',
  group: cohorts
  meta:
    name: cohortNthDay

- dimension: cohort_nth_week
  label: Weekly cohort
  result: string
  description: 'Week offset relative to the firstSessionDate for the users in the cohort. Weeks start on Sunday and end on Saturday. For example, if a cohort is selected with the start and end date in the range 2020-11-08 to 2020-11-14, then for the dates in the range 2020-11-15 to 2020-11-21, cohortNthWeek will be 0001',
  group: cohorts
  meta:
    name: cohortNthWeek

- dimension: cohort_nth_month
  label: Monthly cohort
  result: string
  description: 'Month offset relative to the firstSessionDate for the users in the cohort. Month boundaries align with calendar month boundaries. For example, if a cohort is selected with the start and end date in March 2020, then for any date in April 2020, cohortNthMonth will be 0001',
  group: cohorts
  meta:
    name: cohortNthMonth

- dimension: cohort_nth_week
  label: 'Year'
  result: string
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  group: cohorts
  meta:
    name: cohortNthWeek
# Time dimensions
- dimension: year # "2025"
  label: 'Year'
  result: string
  description: 'The four-digit year of the event. For example, 2020 or 2024',
  group: time
  meta:
    name: year

- dimension: year_month # "202501"
  label: 'Year month'
  result: string
  description: 'The combined values of year and month. Example values include 202212 or 202301',
  group: time
  meta:
    name: yearMonth

- dimension: iso_year_iso_week # "202504"
  label: 'ISO week of ISO year'
  result: string
  description: 'The combined values of isoWeek and isoYear. Example values include 201652 & 201701',
  group: time
  meta:
    name: isoYearIsoWeek

- dimension: year_week # "202505"
  label: 'Year week'
  result: string
  description: 'The combined values of year and week. Example values include 202253 or 202301',
  group: time
  meta:
    name: yearWeek

- dimension: date # "20250127"
  result: string
  description: 'The date of the event, formatted as YYYYMMDD',
  group: time
  meta:
    name: date

- dimension: date_hour # "2025012722"
  label: 'Date hour (YYYYMMDDHH)'
  result: string
  description: 'The combined values of date and hour formatted as YYYYMMDDHH',
  group: time
  meta:
    name: dateHour

- dimension: date_hour_minute # "202501272212"
  label: 'Date hour and minute'
  result: string
  description: 'The combined values of date, hour, and minute formatted as YYYYMMDDHHMM',
  group: time
  meta:
    name: dateHourMinute

- dimension: hour # "4"
  result: string
  description: 'The two-digit hour of the day that the event was logged. This dimension ranges from 0-23 and is reported in your property's timezone',
  group: time
  meta:
    name: hour

- dimension: minute # "40"
  result: string
  description: 'The two-digit minute of the hour that the event was logged. This dimension ranges from 0-59 and is reported in your property's timezone',
  group: time
  meta:
    name: minute

- dimension: day # "26"
  result: string
  description: 'The day of the month, a two-digit number from 01 to 31',
  group: time
  meta:
    name: day

- dimension: day_of_week # "0"
  label: 'Day of week'
  result: string
  description: 'The integer day of the week. It returns values in the range 0 to 6 with Sunday as the first day of the week',
  group: time
  meta:
    name: dayOfWeek

- dimension: day_of_week_name # "Sunday"
  label: 'Day of week name'
  result: string
  description: 'The day of the week in English. This dimension has values such as Sunday or Monday',
  group: time
  meta:
    name: dayOfWeekName

- dimension: week # "05"
  label: 'Week'
  result: string
  description: 'The week of the event, a two-digit number from 01 to 53. Each week starts on Sunday. January 1st is always in week 01. The first and last week of the year have fewer than 7 days in most years. Weeks other than the first and the last week of the year always have 7 days. For years where January 1st is a Sunday, the first week of that year and the last week of the prior year have 7 days',
  group: time
  meta:
    name: week

- dimension: month # "01"
  result: string
  description: 'The month of the event, a two digit integer from 01 to 12',
  group: time
  meta:
    name: month

- dimension: iso_year # "2025"
  label: 'ISO year'
  result: string
  description: 'The ISO year of the event. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 2022 & 2023',
  group: time
  meta:
    name: isoYear

- dimension: iso_week # "04"
  label: 'ISO week of the year'
  result: string
  description: 'ISO week number, where each week starts on Monday. For details, see http://en.wikipedia.org/wiki/ISO_week_date. Example values include 01, 02, & 53',
  group: time
  meta:
    name: isoWeek

- dimension: nth_year # "0000"
  label: 'Nth year'
  result: string
  description: 'The number of years since the start of the date range. The starting year is 0000',
  group: time
  meta:
    name: nthYear

- dimension: nth_month # "0000"
  label: 'Nth month'
  result: string
  description: 'The number of months since the start of a date range. The starting month is 0000',
  group: time
  meta:
    name: nthMonth

- dimension: nth_week # "0001"
  label: 'Nth week'
  result: string
  description: 'A number representing the number of weeks since the start of a date range',
  group: time
  meta:
    name: nthWeek

- dimension: nth_day # "0004"
  label: 'Nth day'
  result: string
  description: 'The number of days since the start of the date range',
  group: time
  meta:
    name: nthDay

- dimension: nth_hour # "0142"
  label: 'Nth hour'
  result: string
  description: 'The number of hours since the start of the date range. The starting hour is 0000',
  group: time
  meta:
    name: nthHour

- dimension: nth_minute # "8532"
  label: 'Nth minute'
  result: string
  description: 'The number of minutes since the start of the date range. The starting minute is 0000',
  group: time
  meta:
    name: nthMinute
