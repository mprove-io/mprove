import fs from 'fs';
import { createRequire } from 'module';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const frontRequire = createRequire(
  path.resolve(__dirname, '../../apps/front/package.json')
);

interface TokenColor {
  scope?: string | string[];
  settings?: { foreground?: string };
}

interface Theme {
  tokenColors?: TokenColor[];
  colors?: Record<string, string>;
  semanticTokenColors?: Record<string, string>;
}

interface StyleEntry {
  tag: string;
  color: string;
}

function processTheme(theme: Theme) {
  let colorMap: Record<string, string> = {};
  let styleMap: StyleEntry[] = [];

  let colorsToProcess: string[] = [];

  if (theme.tokenColors?.length) {
    theme.tokenColors.forEach(token => {
      if (token.settings?.foreground) {
        colorsToProcess.push(token.settings.foreground);
      }
    });
  }

  if (theme.colors) {
    colorsToProcess = [...colorsToProcess, ...Object.values(theme.colors)];
  }

  if (theme.semanticTokenColors) {
    colorsToProcess = [
      ...colorsToProcess,
      ...Object.values(theme.semanticTokenColors)
    ];
  }

  colorsToProcess.sort((a, b) => (a > b ? 1 : b > a ? -1 : 0));

  colorsToProcess.forEach(color => {
    let colorName = color.toUpperCase();

    if (!colorMap[colorName]) {
      let tagName = `color_${colorName.slice(1)}`;
      colorMap[colorName] = tagName;

      styleMap.push({ tag: tagName, color: colorName });
    }
    return colorMap[colorName];
  });

  let tokenColors: TokenColor[] = [];

  Object.entries(colorMap).forEach(([color, tagName]) => {
    tokenColors.push({
      scope: tagName,
      settings: { foreground: color }
    });
  });

  return { colorMap, styleMap, tokenColors };
}

function generateTagsFileContent(
  colorMap: Record<string, string>,
  styleMap: StyleEntry[]
) {
  let colorEntries = Object.entries(colorMap)
    .map(([color, className]) => `  '${color}': '${className}'`)
    .join(',\n');

  let tagDefinitions = Object.values(colorMap)
    .map(className => `  ${className}: Tag.define()`)
    .join(',\n');

  let styleEntries = styleMap
    .map(({ tag, color }) => `  { tag: ct.${tag}, color: '${color}' }`)
    .join(',\n');

  return `// file generated by "pnpm create-light-plus-ext"
import { Tag } from '@lezer/highlight';

export const LIGHT_PLUS_COLOR_TO_TAG: { [color: string]: string } = {
${colorEntries}
};

export const LIGHT_PLUS_CUSTOM_TAGS = {
${tagDefinitions}
};

let ct = LIGHT_PLUS_CUSTOM_TAGS;

export const LIGHT_PLUS_STYLES = [
${styleEntries}
];
`;
}

function processThemeFile(
  themeFilePath: string,
  tagsOutputPath: string,
  extendedOutputPath: string
) {
  let outputDir = path.dirname(extendedOutputPath);
  fs.mkdirSync(outputDir, { recursive: true });

  try {
    let theme: Theme = JSON.parse(
      fs.readFileSync(path.resolve(themeFilePath), 'utf8')
    );

    let { colorMap, styleMap, tokenColors } = processTheme(theme);

    fs.writeFileSync(
      tagsOutputPath,
      generateTagsFileContent(colorMap, styleMap),
      'utf8'
    );
    console.log(`tags - ${tagsOutputPath}`);

    let extendedTheme = {
      ...theme,
      tokenColors: [...tokenColors, ...(theme.tokenColors || [])]
    };
    fs.writeFileSync(
      extendedOutputPath,
      JSON.stringify(extendedTheme, null, 2),
      'utf8'
    );
    console.log(`theme - ${extendedOutputPath}`);
  } catch (error) {
    console.error('Error processing theme:', (error as Error).message);
  }
}

let inputThemePath = frontRequire.resolve('shiki/themes/light-plus.json');

let outputTagsPath = 'libs/common/src/constants/code-themes/light-plus-tags.ts';

let outputThemePath =
  'apps/front/src/assets/shiki-themes/light-plus-extended.json';

processThemeFile(inputThemePath, outputTagsPath, outputThemePath);
